// Copyright Â© Aptos Foundation
// SPDX-License-Identifier: Apache-2.0

// This file was generated. Do not modify!
//
// To update this code, run: `cargo run --release -p framework`.

// Conversion library between a structured representation of a Move script call (`ScriptCall`) and the
// standard BCS-compatible representation used in Aptos transactions (`Script`).
//
// This code was generated by compiling known Script interfaces ("ABIs") with the tool `aptos-sdk-builder`.

#![allow(dead_code)]
#![allow(unused_imports)]
use aptos_types::{
    account_address::AccountAddress,
    transaction::{EntryFunction, TransactionPayload},
};
use move_core_types::{
    ident_str,
    language_storage::{ModuleId, TypeTag},
};

type Bytes = Vec<u8>;

/// Structured representation of a call into a known Move entry function.
/// ```ignore
/// impl EntryFunctionCall {
///     pub fn encode(self) -> TransactionPayload { .. }
///     pub fn decode(&TransactionPayload) -> Option<EntryFunctionCall> { .. }
/// }
/// ```
#[derive(Clone, Debug, PartialEq, Eq)]
#[cfg_attr(feature = "fuzzing", derive(proptest_derive::Arbitrary))]
#[cfg_attr(feature = "fuzzing", proptest(no_params))]
pub enum EntryFunctionCall {
    /// Entry function for creating a collection
    CollectionCreateCollection {
        description: Vec<u8>,
        name: Vec<u8>,
        uri: Vec<u8>,
        max_supply: u64,
        enable_royalty: bool,
        royalty_numerator: u64,
        royalty_denominator: u64,
        royalty_payee_address: AccountAddress,
    },
}

impl EntryFunctionCall {
    /// Build an Aptos `TransactionPayload` from a structured object `EntryFunctionCall`.
    pub fn encode(self) -> TransactionPayload {
        use EntryFunctionCall::*;
        match self {
            CollectionCreateCollection {
                description,
                name,
                uri,
                max_supply,
                enable_royalty,
                royalty_numerator,
                royalty_denominator,
                royalty_payee_address,
            } => collection_create_collection(
                description,
                name,
                uri,
                max_supply,
                enable_royalty,
                royalty_numerator,
                royalty_denominator,
                royalty_payee_address,
            ),
        }
    }

    /// Try to recognize an Aptos `TransactionPayload` and convert it into a structured object `EntryFunctionCall`.
    pub fn decode(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            match SCRIPT_FUNCTION_DECODER_MAP.get(&format!(
                "{}_{}",
                script.module().name(),
                script.function()
            )) {
                Some(decoder) => decoder(payload),
                None => None,
            }
        } else {
            None
        }
    }
}

/// Entry function for creating a collection
pub fn collection_create_collection(
    description: Vec<u8>,
    name: Vec<u8>,
    uri: Vec<u8>,
    max_supply: u64,
    enable_royalty: bool,
    royalty_numerator: u64,
    royalty_denominator: u64,
    royalty_payee_address: AccountAddress,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 4,
            ]),
            ident_str!("collection").to_owned(),
        ),
        ident_str!("create_collection").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&description).unwrap(),
            bcs::to_bytes(&name).unwrap(),
            bcs::to_bytes(&uri).unwrap(),
            bcs::to_bytes(&max_supply).unwrap(),
            bcs::to_bytes(&enable_royalty).unwrap(),
            bcs::to_bytes(&royalty_numerator).unwrap(),
            bcs::to_bytes(&royalty_denominator).unwrap(),
            bcs::to_bytes(&royalty_payee_address).unwrap(),
        ],
    ))
}
mod decoder {
    use super::*;
    pub fn collection_create_collection(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::CollectionCreateCollection {
                description: bcs::from_bytes(script.args().get(0)?).ok()?,
                name: bcs::from_bytes(script.args().get(1)?).ok()?,
                uri: bcs::from_bytes(script.args().get(2)?).ok()?,
                max_supply: bcs::from_bytes(script.args().get(3)?).ok()?,
                enable_royalty: bcs::from_bytes(script.args().get(4)?).ok()?,
                royalty_numerator: bcs::from_bytes(script.args().get(5)?).ok()?,
                royalty_denominator: bcs::from_bytes(script.args().get(6)?).ok()?,
                royalty_payee_address: bcs::from_bytes(script.args().get(7)?).ok()?,
            })
        } else {
            None
        }
    }
}

type EntryFunctionDecoderMap = std::collections::HashMap<
    String,
    Box<
        dyn Fn(&TransactionPayload) -> Option<EntryFunctionCall>
            + std::marker::Sync
            + std::marker::Send,
    >,
>;

static SCRIPT_FUNCTION_DECODER_MAP: once_cell::sync::Lazy<EntryFunctionDecoderMap> =
    once_cell::sync::Lazy::new(|| {
        let mut map: EntryFunctionDecoderMap = std::collections::HashMap::new();
        map.insert(
            "collection_create_collection".to_string(),
            Box::new(decoder::collection_create_collection),
        );
        map
    });
